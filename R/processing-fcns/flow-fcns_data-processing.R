
# test.subst <- function()

#' attr_subset
#'
#' Subset attribute data based on user input and
#' processed spatial data. Depends on many helper sets generated by get-env.R
#' flow-fcns/data-processing
#'
attr_subset <- function( input, showing_cts ) {

  # cdc data compliance
  # keep_vars <- get.cdc.keep.vars(input$outcome)
  keep_vars <- input$outcome

  # subset based on agg_level and outcome/var.name
  out <- metrics[metrics$region.type == input$region_type &
                   metrics$var.name %in% keep_vars, ] %>%
    mutate(region.id = region.id) %>%
    select(c(1:2, "x" = input$indicator,
             "var.name", "outcome", "population")) # , "year"))

  # suppress <10 counts if necessary & save for time-series before year-trim
  # out <- suppress.low.CDC.counts(out)

  return(out)
}

#' subset_and_bin
#'
#' Checks whether values should be scaled based on national distribution or
#' distribution over selection; applies spatial subst and bins either before or
#' afterwards accordingly. flow-fcns/data-processing
#' @inheritParams attr_subset
#' @param attrs a df or tibble with area identifiers
#' @param areas an sf object with matching area identifiers
#' @param gui_inputs additional parameters passed onto appHelpers::bin.var_format
#' @importFrom appHelpers bin.var_format
subset_and_bin <- function(input, attrs, areas, gui_inputs) {  # , n_breaks = 7) {
  require(appHelpers)
  # parse inputs to get color_by_natl
  if( is.null(gui_inputs) )
    color_by_natl = F
  else
    list2env(gui_inputs, globalenv())

  # bin now if using natl distribution or only 1 ct
  if(color_by_natl)   # | nrow(areas) == 1) # a fail-safe I think I can leave out
    attrs$binned_x <- do.call('bin.var_format',
                              (c(x = list(attrs$x), gui_inputs)))

  # spatial subset
  attrs <- inner_join(areas, #appHelpers::remove_multiples(areas),
                      attrs,
                      by = c("region.id"))
                             #,"region.type"))
  # bin now if wasn't done before
  if(!color_by_natl)
    attrs$binned_x <- do.call('bin.var_format',
                              (c(x = list(attrs$x), gui_inputs)))

  return(attrs)
}



# CDC low-n suppression --------------------------------------------------------

#' CDC death data requests we suppress data that shows death data for areas where n <
#' 10. these are helper functions to do that.


#' get.cdc.keep.vars
#'
#' Returns list of columns to keep. Just one for requested output, unless a rate
#' calculated from a CDC variable is kept, and the count will also be retained to
#' ensure cdc data-use compliance. Compliance ensured by trimmed areas with counts
#' less than 10, with \code{......}
get.cdc.keep.vars <- function(selected_outcome,
                                 dod.vars = c("sdeaths_e", "srate_e", "odeaths_e", "orate_e"),
                                 dod.counts = c("sdeaths_e", "odeaths_e")) {

  if (input$outcome %in% setdiff(dod.vars, dod.counts) &
      !input$change_in)
    keep_vars <- c(input$outcome, dod.counts)
  else
    keep_vars <- input$outcome

  return(keep_vars)
}

#' suppress.low.CDC.counts
#'
#' If CDC var selected, and we're not shwoing change-in
suppress.low.CDC.counts <- function(out, input) {

  if ( !input$change_in & input$outcome %in% ts.vars ) {

    out <- out %>%
      tidyr::pivot_wider(values_from = "x",
                         names_from = "var.name") %>%
      appHelpers::suppress_low_counts(input$outcome) %>%
      rename(x = !!input$outcome)
    # to prevent ever_less_then_10s from appearing in TS tab.
    ever_less_than_tens <- out %>%
      count(region.id) %>%
      filter(n < length(unique(dat$year[!is.na(dat$year)]))) %>%
      pull(region.id)

    out <- out %>% filter(!region.id %in% ever_less_than_tens)

    return(out)
  }

  return(out)
}


# umbrella fcns -----------------------------------------------------------------

#' parse.geoseg.data
#'
#' Umbrella fcn to call all steps necessary to parse output for core
#' larger-region-level functionality. Called from mod_geoseg_data server module.
#' flow-fcns/data-processing.
parse.geoseg.data <- function(input, show_cts, gui_inputs) {

  # get attr --------------------------------------------------------------------
  attr <- attr_subset(input, show_cts)

  # get geos --------------------------------------------------------------------
  geos <- geo.list[[input$region_type]]

  # merge & bin -----------------------------------------------------------------
  # (binning happens before subset if coloring by national distribution; otherwise happens after)
  # joining to spatial information happens here too
  out <- subset_and_bin(input, attr, geos, gui_inputs)


  # formatting & rounding -------------------------------------------------------
  out$formatted_x = out$x
  out <- mutate_at(out, c("formatted_x", "outcome"), apply_rounding)

  return(out)
}



