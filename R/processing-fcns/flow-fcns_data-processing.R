
# test.subst <- function()

#' attr_subset
#'
#' Subset attribute data based on user input and
#' processed spatial data. Depends on many helper sets generated by get-env.R
#' flow-fcns/data-processing
#'
attr_subset <- function(input) {

  # cdc data compliance
  # keep_vars <- get.cdc.keep.vars(input$outcome)
  keep_vars <- input$outcome

  # subset based on agg_level and outcome/var.name
  out <- metrics[metrics$region.type == input$region_type &
                   metrics$var.name %in% keep_vars, ] %>%
    mutate(region.id = region.id) %>%
    select(c(1:2, "x" = input$indicator,
             "var.name", "outcome", "population")) # , "year"))

  # suppress <10 counts if necessary & save for time-series before year-trim
  # out <- suppress.low.CDC.counts(out)

  return(out)
}


#' bin_and_format
#'
#' Steps common to any gs/ct data shown in app. Bins continuous variables and gets a
#' formatted column. Assumes column named 'x' to send output. Flow-fcns/data-processing
#' @param df Dataframe to send to display
#' @param ... Add'l arguments passed to \code{bin.var_format}
bin_and_format <- function(df, n_breaks = 7, ...) {

  df$binned_x <- appHelpers::bin.var_format(df$x, ...)

  # formatting & rounding -------------------------------------------------------
  df$formatted_x = df$x
  format_cols <- dplyr::intersect(c("formatted_x", "outcome"), colnames(df))
  df <- mutate(df,
               across(!!format_cols,
                      apply_rounding))

  return(df)
}



# umbrella fcn -----------------------------------------------------------------

#' parse.geoseg.data
#'
#' Umbrella fcn to call all steps necessary to parse output for core
#' larger-region-level functionality. Called from mod_geoseg_data server module.
#' flow-fcns/data-processing.
#' @param input input passed on from shiny, as from \code{geoseg_ui}
#' @inheritParams bin_and_format
parse.geoseg.data <- function(input, ...) {

  # get attr
  attr <- attr_subset(input)

  # join w/ geos
  out <- inner_join(attr,
                    geo.list[[input$region_type]],
                    by = c("region.id"))

  # bin & format & spatialize
  out <- bin_and_format(out, ...)
  out <- st_sf(out)

  return(out)
}



# CDC low-n suppression --------------------------------------------------------

#' CDC death data requests we suppress data that shows death data for areas where n <
#' 10. these are helper functions to do that.


#' get.cdc.keep.vars
#'
#' Returns list of columns to keep. Just one for requested output, unless a rate
#' calculated from a CDC variable is kept, and the count will also be retained to
#' ensure cdc data-use compliance. Compliance ensured by trimmed areas with counts
#' less than 10, with \code{......}
get.cdc.keep.vars <- function(selected_outcome,
                              dod.vars = c("sdeaths_e", "srate_e", "odeaths_e", "orate_e"),
                              dod.counts = c("sdeaths_e", "odeaths_e")) {

  if (input$outcome %in% setdiff(dod.vars, dod.counts) &
      !input$change_in)
    keep_vars <- c(input$outcome, dod.counts)
  else
    keep_vars <- input$outcome

  return(keep_vars)
}

#' suppress.low.CDC.counts
#'
#' If CDC var selected, and we're not shwoing change-in
suppress.low.CDC.counts <- function(out, input) {

  if ( !input$change_in & input$outcome %in% ts.vars ) {

    out <- out %>%
      tidyr::pivot_wider(values_from = "x",
                         names_from = "var.name") %>%
      appHelpers::suppress_low_counts(input$outcome) %>%
      rename(x = !!input$outcome)
    # to prevent ever_less_then_10s from appearing in TS tab.
    ever_less_than_tens <- out %>%
      count(region.id) %>%
      filter(n < length(unique(dat$year[!is.na(dat$year)]))) %>%
      pull(region.id)

    out <- out %>% filter(!region.id %in% ever_less_than_tens)

    return(out)
  }

  return(out)
}
